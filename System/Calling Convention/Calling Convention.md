# Calling Convention

## 함수 호출 규약

---

<aside>
📢 함수의 `호출 및 반환`에 대한 약속

</aside>

```c
int sum(int a, int b)
{
	return a+b;
}

int main(void)
{
	int a=3;
	int b=7;
	
	int result = sum(a,b);
	printf("%d",result);
	return 0;
}
```

( main 함수 안에서 sum 함수를 호출하는 예시 )

한 함수에서 다른 함수를 호출 할 때 `프로그램의 실행 흐름`은 다른 함수로 이동하고

호출한 함수가 반환하면 다시 원래의 함수로 돌아와서 `실행 흐름`을 이어간다.

따라서 함수를 호출 할 때는 반환되고 난 `이후`를 위하여

호출자 ( `Caller` ) 의 상태 및 반환 주소 ( `Return Address` )를 `저장`해야 한다.

또한 호출자는 피호출자 ( `Callee` )가 요구하는 인자를 전달해줘야 하며, 피호출자의 실행이 종료될 때

`반환값을 전달` 받아야 한다.

이런 함수 호출 규약을 적용하는 건 `컴파일러의` 몫이다.

프로그래머가 고급 언어로 작성하면 컴파일러가 `규약`에 맞게 `컴파일` 해준다.

따라서 대부분의 프로그래머는 함수 호출 규약을 알지 않아도 `무관`하다.

그러나 `어셈블리` 코드를 작성하거나, `어셈블리` 코드를 읽고자 한다면 `함수 호출 규약을 알아야한다.`

## 함수 호출 규약의 종류

---

<aside>
📢 컴파일러는 지원하는 호출 규약 중에 CPU 아키텍처에 적합한 것을 선택한다.

</aside>

예를 들어 x86 ( `32bit` ) 아키텍처는 레지스터의 수가 적어서 `스택`으로 인자를 전달하는 규약을 사용한다.

하지만 `x86-64` 아키텍처에서는 레지스터가 많으므로 적은 수의 인자는 레지스터로 전달하고,

인자의 수가 `많을 때만 스택`을 사용한다.

CPU의 아키텍처가 같아도 다른 함수 호출 규약을 사용하는 경우도 있다.

Ex) 리눅스 = gcc = SYSTEM V / 윈도우 = MSVC =  MS x64

## x86 호출 규약 : cdecl

---

x86 아키텍처는 레지스터의 수가 적어, `스택`을 통해 인자를 전달한다.

또한 인자를 전달하기 위해 사용한 스택을 `호출자`가 정리하는 특징이 있다.

스택을 통해 인자를 전달할 때는, 마지막 인자부터 첫 번째 인자까지 거꾸로 스택에 `push`한다.

## x86-64 호출 규약 : SYSV

---

리눅스는 `SYSTEM V` ( SYSV ) `Application Binary Interface` (ABI)를 기반으로 만들어졌다.

`SYSV ABI`는 ELF 포맷, 링킹 방법, 함수 호출 규약등의 내용을 담고 있다.

### SYSV에서 정의한 함수 호출 규약

1. 6개의 인자를 `RDI, RSI, RDX, RCX, R8, R9`에 순서대로 저장 ( 그 이상은 스택 사용 )
2. `Caller`에서 인자 전달에 사용된 스택 정리
3. 함수의 반환 값은 `RAX`로 전달