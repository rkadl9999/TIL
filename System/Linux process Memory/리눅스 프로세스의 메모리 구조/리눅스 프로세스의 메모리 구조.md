# 리눅스 프로세스의 메모리 구조

## 세그먼트

> 리눅스에서는 프로세스의 메모리를 크게 5가지의 `세그먼트 ( Segment )`로 구분한다.
> 

![스크린샷 2022-04-28 오전 11.55.53.png](%E1%84%85%E1%85%B5%E1%84%82%E1%85%AE%E1%86%A8%E1%84%89%E1%85%B3%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%B4%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9%20c3f57e73537a49879c5f366c0df7383a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-04-28_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_11.55.53.png)

## 코드 세그먼트

> 실행 가능한 기계 코드가 위치하는 영역 ( 텍스트 세그먼트 라고도 불림 )
> 

프로그램이 동작하려면 코드를 실행해야하므로 `읽기 권한과 실행 권한`이 주어진다.

반면 `쓰기 권한`을 주게 되면 공격자가 악의적인 코드를 주입할 수 있으므로 보통의 경우 `제거한다.`

예를 들어 

```c
int main() {
	return 31337;
}
```

라는 코드를  기계어로 변환 시에 `554889e5b8697a00005dc3` 이와 같이 나오는데 이 기계 코드가 코드 세그먼트에 위치된다.

## 데이터 세그먼트

> 컴파일 시점에 값이 정해진 `전역 변수` 및 `전역 상수`들이 위치
> 

쓰기가 가능한 세그먼트 = data 세그먼트 ( `변수` )

쓰기가 불가능한 세그먼트 = rodata 세그먼트 ( `상수` )

예제.

```c
int data_num = 31337; //data
char data_rwstr[] = "writeable_data"; //data
const char data_rostr[] = "readonly_data"; //rodata
char *str_ptr = "readonly"; //str_ptr은 data , 문자열은 rodata

int main(){...}
```

## BSS 세그먼트

> 컴파일 시점에 `값이 정해지지 않은 전역 변수`가 위치
> 

개발자가 `선언만` 하고 값을 넣지 않은 전역 변수가 위치

이 세그먼트는 프로그램이 시작될 때 값이 모두 `0으로 초기화`

`읽기,쓰기` 권한 주어짐

## 힙 세그먼트

> 힙 데이터가 위치하는 세그먼트
> 

실행중에 `동적`으로 할당 가능.

스택 세그먼트와 `반대 방향`으로 자람

C언어에서 `malloc(), calloc()` 등으로 할당받는 메모리가 힙에 위치된다.

## 스택 세그먼트

> 프로세스의 스택이 위치, `함수의 인자`나, `지역 변수`와 같은 임시 변수가 위치
> 

`아래`로 자라고 `읽기, 쓰기` 권한 부여